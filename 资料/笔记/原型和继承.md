<H3>原型和继承

<H4>
    es5
</h4>

对象和函数的原型

对象的原型 Prototype

获取原型 obj.\__proto__

标准方式

Object.getPrototypeOf(obj)

对象查找属性,如果二米查到,会去原型查找

1.将函数看成普通的对象是,它具备\__proto__(隐式原型）

2.将函数看成一个函数时,它具有prototype,显示原型

<h4>new的操作过程

1.创建空对象

var obj = {}

2.将这个空对象赋值给this

this =  obj

3.**将函数的显示原型赋值给这个对象作为它的隐式原型**

**obj.\__proto__ = Person.prototype**

4执行函数体中代码

5将这个对象默认返回



<h4>将函数放在原型上

函数放在构造函数内部，每次new都会创建一次，且每个函数还不通

只有放在显示prototype上，每次new都能得到相同的隐式原型

当多个对象共同拥有共同点额值，我们可以将它放到构造函数对象的显示原型

由构造函数创建出来的所有对象，都讲共享这些属性



Person.prototype 是Object

Person.prototype.constructor = Person

![1663740051855](C:\Users\dyqiang\AppData\Roaming\Typora\typora-user-images\1663740051855.png)

<h4>重写函数原型对象

![1663741146219](C:\Users\dyqiang\AppData\Roaming\Typora\typora-user-images\1663741146219.png)

需要手动指定constructor指向

<h4>面向对象的特性-继承

<h3>原型链

从一个对象上获取属性,如果在当前对象中没有获取到就会在它的原型上面获取

![1663742367387](C:\Users\dyqiang\AppData\Roaming\Typora\typora-user-images\1663742367387.png)

1.直接将父类的原型直接复制给子类

缺点:父类和子类共享一个原型对象,修改一个,另一个也会变

Student.prototype =Person.prototype

2.创建一个父类的实例(new Person()),用这个实例对象来作为子类的原型对象

var p = new Person("why",18)

Student.prototype = p

![1663744797153](C:\Users\dyqiang\AppData\Roaming\Typora\typora-user-images\1663744797153.png)

![1663744829991](C:\Users\dyqiang\AppData\Roaming\Typora\typora-user-images\1663744829991.png)

这种做法的弊端![1663744997182](C:\Users\dyqiang\AppData\Roaming\Typora\typora-user-images\1663744997182.png)

<h4>借用构造函数

![1663745354474](C:\Users\dyqiang\AppData\Roaming\Typora\typora-user-images\1663745354474.png)

借用父类的函数,改变父类的函数中的this;

<h4>组合借用继承的问题

![1663746442792](C:\Users\dyqiang\AppData\Roaming\Typora\typora-user-images\1663746442792.png)

<h4>寄生式继承

![1663747388080](C:\Users\dyqiang\AppData\Roaming\Typora\typora-user-images\1663747388080.png)

![1663747995316](C:\Users\dyqiang\AppData\Roaming\Typora\typora-user-images\1663747995316.png)

![1663748050148](C:\Users\dyqiang\AppData\Roaming\Typora\typora-user-images\1663748050148.png)

<h4>Object是其他类的父类

![1663748364392](C:\Users\dyqiang\AppData\Roaming\Typora\typora-user-images\1663748364392.png)

var A  = createObject(B)

A继承B

判断当前原型是否有某属性 hasOwnProperty()

value in info

value 是否在info的原型上，所有的原型

for in 遍历的不仅是自己对象上的内容，还包括原型上的内容

instanceof  用于检测构造函数的prototype，是否出现在某个实例对象的原型链上。原理就是看原型链是否有constructor，判断实例对象和类的关系

![1663749429826](C:\Users\dyqiang\AppData\Roaming\Typora\typora-user-images\1663749429826.png)

\__proto__指向constructor

isPrototypeOf 用于检测某个对象，是否出现在某个实例对象的原型链上，用于判断对象之间的继承

![1663749474357](C:\Users\dyqiang\AppData\Roaming\Typora\typora-user-images\1663749474357.png)

<h4>继承图解

Function也是有原型的

函数既有隐式原型也有显示原型，new的过程显示原型会赋值给隐性原型。

对象只有隐式原型，都最终指向Object的原型，Object的原型\__proto__是null

![1663754348910](C:\Users\dyqiang\AppData\Roaming\Typora\typora-user-images\1663754348910.png)

弄清*实例对象，函数，原型对象之间的关系*

**定义一个函数的本质是new Function()**

var p1 = new foo()

function Object(){}

var o1 = new Object()也是通过函数创建

****

p1的隐式原型指向foo的prototype

函数也是对象，函数的隐式原型 foo.\__proto__ === Function.prototype

Object.\__proto__ === Function.prototype

foo的隐式原型指向Function的prototype

Function原型对象隐式原型指向Object的原型对象

![1663755718133](C:\Users\dyqiang\AppData\Roaming\Typora\typora-user-images\1663755718133.png)

**显示原型都会指向Function的prototype,因为Function/Object/foo都是Function的实例对象,**

**隐式原型都指向Object的显示原型,因为Object是Function/foo的父类,Object的显示原型为null.(浏览器设置)**

**对象只有隐式原型,函数既有隐式也有显示,因为函数也是对象**

**下级的显示原型,指向上级的隐式原型**

<h4>new的操作过程

1.创建空对象

var obj = {}

2.将这个空对象赋值给this

this =  obj

3.**将函数的显示原型赋值给这个对象作为它的隐式原型**

**obj.\__proto__ = Person.prototype**

4执行函数体中代码

5将这个对象默认返回





实例方法要和对象绑定起来,对象是主体,方法是功能

<h4>类方法

通过类名直接调用的方法

![1663757337826](C:\Users\dyqiang\AppData\Roaming\Typora\typora-user-images\1663757337826.png)

实例方法

![1663757352442](C:\Users\dyqiang\AppData\Roaming\Typora\typora-user-images\1663757352442.png)

**具体数字,字符串调用的就是实例方法**

"abc".splice()

